## 素数判定 O(log N)

```ruby
require "prime"
N.prime?
```

## 素因数分解 O(√N)

```ruby
require "prime"
Hash[N.prime_division]
```

## 素数列挙 O(N log log N)

```ruby
require "prime"
primes = Prime.each(N).to_a
```

## N^-1 mod p O(log p)

```ruby
N.pow(p - 2, p)
```

## N^-1 mod m O(log m)
定数倍は重い

```ruby
require "openssl"
N.to_bn.mod_inverse(m).to_i
```

## 約数列挙 O(√n)

```ruby
def factors(n, &block)
  e = Enumerator.new do |y|
    k = 1
    while k * k < n
      if n % k == 0
        y << k
        y << n / k
      end
      k += 1
    end
    y << k if k * k == n
  end
  return e unless block_given?
  e.each(&block)
end
```

## 約数の総和

### 約数から求める O(√N)

```ruby
factors(N).sum
```

### 素因数分解から求める <O(√N), O(log N log log N)>

```ruby
N.prime_division.inject(1) { |prod, (p, e)| prod * (p**(e + 1) - 1) / (p - 1) }
```

## 素数テーブル（線形篩） O(N)

```ruby
class PrimeTable
	def initialize(n)
		@lpf = [nil] * (n + 1)
		@primes = [2]
		(2 .. n).step(2) do |d| @lpf[d] = 2 end
		(3 .. n).step(2) do |d|
			unless @lpf[d]
				@lpf[d] = d
				@primes << d
			end
			@primes.each do |p|
				break if p * d > n or p > @lpf[d]
				@lpf[p * d] = p
			end
		end
	end
	def prime?(n); @lpf[n] == n; end
	def each(&block); @primes.each(&block); end
	def factorize(n); fs = Hash.new(0); while n > 1; fs[f = @lpf[n]] += 1; n /= f; end; fs; end
end
```

## nCk mod p <O(N), O(1)>

```ruby
class Factorial
  def initialize(max, mod)
    @mod = mod
    @fac = [1, 1]
    @fin = [1, 1]
    @inv = [nil, 1]
    (2 .. max).each do |i|
      @fac[i] = @fac[i - 1] * i % mod
      @inv[i] = mod - @inv[mod % i] * (mod / i) % mod
      @fin[i] = @fin[i - 1] * @inv[i] % mod
    end
  end
  
  def fact(n)
    @fac[n]
  end
  
  def comb(n, k)
    return 0 if n < k or n < 0 or k < 0
    @fac[n] * @fin[k] % @mod * @fin[n - k] % @mod
  end
end
```
