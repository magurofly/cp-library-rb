## 素数判定 O(log N)

```ruby
require "prime"
N.prime?
```

## 素因数分解 O(√N)

```ruby
require "prime"
Hash[N.prime_division]
```

## 素数列挙 O(N log log N)

```ruby
require "prime"
primes = Prime.each(N).to_a
```

## N^-1 mod p O(log p)

```ruby
N.pow(p - 2, p)
```

## N^-1 mod m O(log m)
定数倍は重い

```ruby
require "openssl"
N.to_bn.mod_inverse(m).to_i
```

## 約数列挙 O(√n)

```ruby
def factors(n, &block)
  e = Enumerator.new do |y|
    k = 1
    while k * k < n
      if n % k == 0
        y << k
        y << n / k
      end
      k += 1
    end
    y << k if k * k == n
  end
  return e unless block_given?
  e.each(&block)
end
```

## 約数の総和

### 約数から求める O(√N)

```ruby
factors(N).sum
```

### 素因数分解から求める <O(√N), O(log N log log N)>

```ruby
N.prime_division.inject(1) { |prod, (p, e)| prod * (p**(e + 1) - 1) / (p - 1) }
```

## 素数テーブル（線形篩） O(N)

```ruby
class PrimeTable
	def initialize(n)
		@lpf = [nil] * (n + 1)
		@primes = [2]
		(2 .. n).step(2) do |d| @lpf[d] = 2 end
		(3 .. n).step(2) do |d|
			unless @lpf[d]
				@lpf[d] = d
				@primes << d
			end
			@primes.each do |p|
				break if p * d > n or p > @lpf[d]
				@lpf[p * d] = p
			end
		end
	end
	def prime?(n); @lpf[n] == n; end
	def each(&block); @primes.each(&block); end
	def factorize(n); fs = Hash.new(0); while n > 1; fs[f = @lpf[n]] += 1; n /= f; end; fs; end
end
```
